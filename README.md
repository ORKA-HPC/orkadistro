# Docker-based build environment and runtime for ORKA-HPC

## Build environment requirements

- A GNU/Linux distribution with a recent kernel (>= 5, problems have been reported on 3.x).
- Docker v19.0 or higher
- Optional: You need a research license for the EDG C++ frontend
  1. Contact `info@edg.com`
  2. Write that you need access to the EDG C++ frontend
     sources. To make things as smooth as possible for you,
     you should put me (`florian.andrefranc.mayer@fau.de`) on CC.
     Tell them that you need a research license for EDG in order
     to compile the ROSE toolchain from the sources. State that
     ORKA-HPC is using a custom ROSE fork that won't work with
     the pre-built EDG binaries from the standard ROSE distribution.
  3. Once you got it, mail the license to me.
  4. I will then give you access to a private
     repository containing ROSE's custom EDG sources.

## Getting Started

### Building the ORKA-HPC

To initialize ORKA-HPC, use: 
`[ CLEAN_BUILD=1 ] [ NO_EDG_REPO=1 ] ./setup.sh [ --init | --clean-after-pull | --after-pull ]`

You can build the ORKA-HPC development environment with or without
a EDG research license. When the environment variable
`NO_EDG_REPO=1` is present, `setup.sh` will not try to
use the EDG sources. Instead it will download a pre-built
package of EDG binaries during the build process.
In the following examples, `[ VAR=1 ] ./setup.sh ...` means
that the variable assignment `VAR=1` is optional.
See section `Frequent Issues` if `setup.sh` fails.

- `--init` builds the ORKA-HPC Docker image, creates
  an initial container, and volume-mounts most of the submodules in
  this repo. It builds the sources in these submodules
  **inside** the Docker container, creates Debian packages for
  each submodule, and installs them **inside** the container.

- `--after-pull` rebuilds the docker container (which is
  necessary after a pull of orkadistro.
  It tries to reuse previously compiled code.
  Docker, by default, will try to re-use those commands
  in the Dockerfile that have not changed between commits.
  However, due to that caching, sometimes inconsistencies sneak in.
  If you encounter strange errors later on,
- try to use `--clean-after-pull`.

### Operate ORKA-HPC

The following commands assume that you pulled orkadistro and
executed `setup.sh --init`.

- `./run_docker.sh -r` tries to create a Docker container,
  to establish volume mounts, and to launch the container in the background.
  If a ORKA-HPC Docker container happens to be present it will be woken up.

- `./run_docker.sh -e` opens a shell in the
  ORKA-HPC Docker container ready for developer interaction.

- `./run_docker.sh -q` stops the container. The container is
  basically suspended and can be woken up with `-r`.

- `./run_docker.sh --stop-and-remove` stops and removes the
  running container. All your data in the container is
  erased that way.

### Notes

`rebuild_docker.sh` builds a docker image with the
following name: `orkadistro-img-<git-ref>`, where git-ref
is the git commit hash of this repository. This ensures
that you can test and run different Docker images.

`run_docker.sh` starts a docker container with the
following name: `orkadistro-cont-<sha256-hash>`, where
sha256-hash is generated by hashing the content of 
`$PWD`. This ensures that doing

```bash
( git clone <orkadistro-uri> orkadistro && cd orkadistroA \
  && ./setup.sh --init && ./run_docker -r -e -q )
( git clone <orkadistro-uri> orkadistro && cd orkadistroB \
  && ./setup.sh --init && ./run_docker -r -e -q )
```

gives you access to two _different_ instances of the
same images!

## Hacking on ORKA-HPC

Most of our software dependencies are managed by way of the
Docker container. Thus, the `Dockerfile` serves as executable
description of the build and runtime environment that we
depend upon.

There are however special dependencies that we manage via
Git submodules. This repository contains a list of these
submodules in `.gitmodules`. List all submodules with

`$ git submodule`

When you built ORKA-HPC via `setup.sh --init` you should
not have to worry about submodules. The script automatically
checks out  orkadistro's submodules before it begins to build
the Docker container.
`setup.sh --after-pull` also checks out those submodules.
Note that this does **checkout specific commit references of all submodules**. 
This means that orkadistro's submodules
get initialized to **the exact same** set of files for any given
revision of orkadistro. Hence, if you commit to a branch on one 
of the submodules, this commit will not show up in the work tree 
of the checked out submodule unless you explicitly update the
submodule pointer in orkadistro itself.

Therefore, if you want to try out such a submodule commit, you
have to manually checkout that commit (or better the corresponding branch)
in the submodule. Note, that each submodule initialized by
`setup.sh --after-pull` will be in the `detached HEAD state`. 
Everything you commit there will be hard to get onto a branch.
You have to first checkout a branch on origin, e.g:

`$ cd llp_tapasco/tapasco_llp_repo && git checkout --track origin/develop`.

Note, that you can only checkout a tracking `--track` branch once; use
`git checkout develop` afterwards.

## Frequent Issues

- docker permission issues:
    - `sudo groupadd docker`
    - `sudo usermod -aG docker ${USER}`
    - `sudo service docker restart`
    - Log out and back in.

- You need to run `run_docker.sh --stop-and-unmount` before
  you can `./rebuild.sh` the image again.

## Notes and References

The arty board description files were retrieved from
[github](https://github.com/Digilent/vivado-boards)
